openapi: 3.0.3
servers:
  - url: 'https://{serverURL}/ga4gh/drs/v1'
    variables:
      serverURL:
        default: drs.example.org
        description: >
          DRS server endpoints MUST be prefixed by the '/ga4gh/drs/v1' endpoint 
          path
info:
  title: Data Repository Service
  version: 1.1.0
  x-logo:
    url: >-
      https://www.ga4gh.org/wp-content/themes/ga4gh-theme/gfx/GA-logo-horizontal-tag-RGB.svg
  description: >-
    # Introduction


    The Data Repository Service (DRS) API provides a generic interface to data
    repositories so data consumers, including workflow systems, can access data
    objects in a single, standard way regardless of where they are stored and
    how they are managed. The primary functionality of DRS is to map a logical
    ID to a means for physically retrieving the data represented by the ID. The
    sections below describe the characteristics of those IDs, the types of data
    supported, how they can be pointed to using URIs, and how clients can use
    these URIs to ultimately make successful DRS API requests. This document
    also describes the DRS API in detail and provides information on the
    specific endpoints, request formats, and responses. This specification is
    intended for developers of DRS-compatible services and of clients that will
    call these DRS services.


    The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD
    NOT, RECOMMENDED, MAY, and OPTIONAL in this document are to be interpreted
    as described in [RFC 2119](https://datatracker.ietf.org/doc/html/rfc2119).


    # DRS API Principles


    ## DRS IDs


    Each implementation of DRS can choose its own id scheme, as long as it
    follows these guidelines:


    * DRS IDs are strings made up of uppercase and lowercase letters, decimal
    digits, hypen, period, underscore and tilde [A-Za-z0-9.-_~]. See [RFC 3986 §
    2.3](https://datatracker.ietf.org/doc/html/rfc3986#section-2.3).

    * DRS IDs can contain other characters, but they MUST be encoded into valid
    DRS IDs whenever they are used in API calls. This is because non-encoded IDs
    may interfere with the interpretation of the objects/{id}/access endpoint.
    To overcome this limitation use percent-encoding of the ID, see [RFC 3986 §
    2.4](https://datatracker.ietf.org/doc/html/rfc3986#section-2.4)

    * One DRS ID MUST always return the same object data (or, in the case of a
    collection, the same set of objects). This constraint aids with
    reproducibility.

    * DRS implementations MAY have more than one ID that maps to the same
    object.

    * DRS version 1.x does NOT support semantics around multiple versions of an
    object. (For example, there’s no notion of “get latest version” or “list all
    versions”.) Individual implementations MAY choose an ID scheme that includes
    version hints.


    ## DRS URIs


    For convenience, including when passing content references to a [WES
    server](https://github.com/ga4gh/workflow-execution-service-schemas), we
    define a [URI
    scheme](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Generic_syntax)
    for DRS-accessible content. This section documents the syntax of DRS URIs,
    and the rules clients follow for translating a DRS URI into a URL that they
    use for making the DRS API calls described in this spec.


    There are two styles of DRS URIs, Hostname-based and Compact
    Identifier-based, both using the `drs://` URI scheme. DRS servers may choose
    either style when exposing references to their content;. DRS clients MUST
    support resolving both styles.


    Tip:

    > See [Appendix: Background Notes on DRS URIs](#) for more information on
    our design motivations for DRS URIs.


    ### Hostname-based DRS URIs


    Hostname-based DRS URIs are simpler than compact identifier-based URIs. They
    contain the DRS server name and the DRS ID only and can be converted
    directly into a fetchable URL based on a simple rule. They take the form:


    ```

    drs://<hostname>/<id>

    ```


    DRS URIs of this form mean *\"you can fetch the content with DRS id \<id\>
    from the DRS server at \<hostname\>\"*.

    For example, here are the client resolution steps if the URI is:


    ```

    drs://drs.example.org/314159

    ```


    1. The client parses the string to extract the hostname of “drs.example.org”
    and the id of “314159”.

    2. The client makes a GET request to the DRS server, using the standard DRS
    URL syntax:


    ```

    GET https://drs.example.org/ga4gh/drs/v1/objects/314159

    ```


    The protocol is always https and the port is always the standard 443 SSL
    port. It is invalid to include a different port in a DRS hostname-based URI.


    Tip:

    > See the [Appendix: Hostname-Based URIs](#) for information on how
    hostname-based DRS URI resolution to URLs is likely to change in the future,
    when the DRS v2 major release happens.


    ### Compact Identifier-based DRS URIs


    Compact Identifier-based DRS URIs use resolver registry services
    (specifically, [identifiers.org](https://identifiers.org/) and [n2t.net
    (Name-To-Thing)](https://n2t.net/)) to provide a layer of indirection
    between the DRS URI and the DRS server name — the actual DNS name of the DRS
    server isn’t present in the URI. This approach is based on the Joint
    Declaration of Data Citation Principles as detailed by [Wimalaratne et al
    (2018)](https://www.nature.com/articles/sdata201829).


    For more information, see the document [More Background on Compact
    Identifiers](#).


    Compact Identifiers take the form:


    ```

    drs://[provider_code/]namespace:accession

    ```


    Together, provider code and the namespace are referred to as the `prefix`.
    The provider code is optional and is used by identifiers.org/n2t.net for
    compact identifier resolver mirrors. Both the `provider_code` and
    `namespace` disallow spaces or punctuation, only lowercase alphanumerical
    characters, underscores and dots are allowed (e.g. [A-Za-z0-9._]).


    Tip:

    > See the [Appendix: Compact Identifier-Based URIs](#) for more background
    on Compact Identifiers and resolver registry services like
    identifiers.org/n2t.net (aka meta-resolvers), how to register prefixes,
    possible caching strategies, and security considerations.


    #### For DRS Servers


    If your DRS implementation will issue DRS URIs based *on your own* compact
    identifiers, you MUST first register a new prefix with identifiers.org
    (which is automatically mirrored to n2t.net). You will also need to include
    a provider resolver resource in this registration which links the prefix to
    your DRS server, so that DRS clients can get sufficient information to make
    a successful DRS GET request. For clarity, we recommend you choose a
    namespace beginning with `drs`.


    #### For DRS Clients


    A DRS client parses the DRS URI compact identifier components to extract the
    prefix and the accession, and then uses meta-resolver APIs to locate the
    actual DRS server. For example, here are the client resolution steps if the
    URI is:


    ```

    drs://drs.42:314159

    ```


    1. The client parses the string to extract the prefix of `drs.42` and the
    accession of `314159`, using the first occurrence of a colon (":") character
    after the initial `drs://` as a delimiter. (The colon character is not
    allowed in a Hostname-based DRS URI, making it easy to tell them apart.)


    2. The client makes API calls to a meta-resolver to look up the URL pattern
    for the namespace. (See [Calling Meta-Resolver APIs for Compact
    Identifier-Based DRS URIs](#) for details.) The URL pattern is a string
    containing a `{$id}` parameter, such as:


    ```

    https://drs.myexample.org/ga4gh/drs/v1/objects/{$id}

    ```


    3. The client generates a DRS URL from the URL template by replacing {$id}
    with the accession it extracted in step 1. It then makes a GET request to
    the DRS server:


    ```

    GET https://drs.myexample.org/ga4gh/drs/v1/objects/314159

    ```


    4. The client follows any HTTP redirects returned in step 3, in case the
    resolver goes through an extra layer of redirection.


    For performance reasons, DRS clients SHOULD cache the URL pattern returned
    in step 2, with a suggested 24 hour cache life.


    ### Choosing a URI Style


    DRS servers can choose to issue either hostname-based or compact
    identifier-based DRS URIs, and can be confident that compliant DRS clients
    will support both. DRS clients must be able to accommodate both URI types.
    Tradeoffs that DRS server builders, and third parties who need to cite DRS
    objects in datasets, workflows or elsewhere, may want to consider include:


    *Table 1: Choosing a URI Style*


    |                   | Hostname-based | Compact Identifier-based |

    |-------------------|----------------|--------------------------|

    | URI Durability    | URIs are valid for as long as the server operator
    maintains ownership of the published DNS address. (They can of course point
    that address at different physical serving infrastructure as often as they’d
    like.) | URIs are valid for as long as the server operator maintains
    ownership of the published compact identifier resolver namespace. (They also
    depend on the meta-resolvers like identifiers.org/n2t.net remaining
    operational, which is intended to be essentially forever.) |

    | Client Efficiency | URIs require minimal client logic, and no network
    requests, to resolve. | URIs require small client logic, and 1-2 cacheable
    network requests, to resolve. |

    | Security          | Servers have full control over their own security
    practices. | Server operators, in addition to maintaining their own security
    practices, should confirm they are comfortable with the resolver registry
    security practices, including protection against denial of service and
    namespace-hijacking attacks. (See the [Appendix: Compact Identifier-Based
    URIs](#) for more information on resolver registry security.) |


    ## DRS Datatypes


    DRS v1 supports two types of content:


    * a blob is like a file — it’s a single blob of bytes, represented by a
    DrsObject without a contents array

    * a bundle is like a folder — it’s a collection of other DRS content (either
    blobs or bundles), represented by a DrsObject with a contents array


    ## Read-only


    DRS v1 is a read-only API. We expect that each implementation will define
    its own mechanisms and interfaces (graphical and/or programmatic) for adding
    and updating data.


    ## Standards


    The DRS API specification is written in OpenAPI and embodies a RESTful
    service philosophy. It uses JSON in requests and responses and standard
    HTTPS on port 443 for information transport.
  termsOfService: 'https://www.ga4gh.org/terms-and-conditions/'
  contact:
    name: GA4GH Cloud Work Stream
    email: ga4gh-cloud@ga4gh.org
  license:
    name: Apache 2.0
    url: >-
      https://raw.githubusercontent.com/ga4gh/data-repository-service-schemas/master/LICENSE
security:
  - {}
  - BasicAuth: []
  - BearerAuth: []
paths:
  '/objects/{object_id}':
    get:
      summary: Get info about a `DrsObject`.
      description: >-
        Returns object metadata, and a list of access methods that can be used
        to fetch object bytes.
      operationId: GetObject
      parameters:
        - $ref: '#/components/parameters/objectId'
        - $ref: '#/components/parameters/expand'
      responses:
        '200':
          $ref: '#/components/responses/200OkDrsObject'
        '202':
          $ref: '#/components/responses/202Accepted'
        '400':
          $ref: '#/components/responses/400BadRequest'
        '401':
          $ref: '#/components/responses/401Unauthorized'
        '403':
          $ref: '#/components/responses/403Forbidden'
        '404':
          $ref: '#/components/responses/404NotFoundDrsObject'
        '500':
          $ref: '#/components/responses/500InternalServerError'
      tags:
        - DataRepositoryService
      x-swagger-router-controller: ga4gh.drs.server
  '/objects/{object_id}/access/{access_id}':
    get:
      summary: Get a URL for fetching bytes
      description: >-
        Returns a URL that can be used to fetch the bytes of a `DrsObject`.


        This method only needs to be called when using an `AccessMethod` that
        contains an `access_id` (e.g., for servers that use signed URLs for
        fetching object bytes).
      operationId: GetAccessURL
      parameters:
        - $ref: '#/components/parameters/objectId'
        - $ref: '#/components/parameters/accessId'
      responses:
        '200':
          $ref: '#/components/responses/200OkAccess'
        '202':
          $ref: '#/components/responses/202Accepted'
        '400':
          $ref: '#/components/responses/400BadRequest'
        '401':
          $ref: '#/components/responses/401Unauthorized'
        '403':
          $ref: '#/components/responses/403Forbidden'
        '404':
          $ref: '#/components/responses/404NotFoundAccess'
        '500':
          $ref: '#/components/responses/500InternalServerError'
      tags:
        - DataRepositoryService
      x-swagger-router-controller: ga4gh.drs.server
components:
  schemas:
    Checksum:
      type: object
      required:
        - checksum
        - type
      properties:
        checksum:
          type: string
          description: The hex-string encoded checksum for the data
        type:
          type: string
          description: >-
            The digest method used to create the checksum.


            The value (e.g. `sha-256`) SHOULD be listed as `Hash Name String` in
            the
            https://www.iana.org/assignments/named-information/named-information.xhtml#hash-alg[IANA
            Named Information Hash Algorithm Registry]. Other values MAY be
            used, as long as implementors are aware of the issues discussed in
            https://tools.ietf.org/html/rfc6920#section-9.4[RFC6920].


            GA4GH may provide more explicit guidance for use of
            non-IANA-registered algorithms in the future. Until then, if
            implementors do choose such an algorithm (e.g. because it's
            implemented by their storage provider), they SHOULD use an existing
            standard `type` value such as `md5`, `etag`, `crc32c`, `trunc512`,
            or `sha1`.
          example: sha-256
    DrsObject:
      type: object
      required:
        - id
        - self_uri
        - size
        - created_time
        - checksums
      properties:
        id:
          type: string
          description: An identifier unique to this `DrsObject`
        name:
          type: string
          description: >-
            A string that can be used to name a `DrsObject`.

            This string is made up of uppercase and lowercase letters, decimal
            digits, hypen, period, and underscore [A-Za-z0-9.-_]. See
            http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_282[portable
            filenames].
        self_uri:
          type: string
          description: >-
            A drs:// hostname-based URI, as defined in the DRS documentation,
            that tells clients how to access this object.

            The intent of this field is to make DRS objects self-contained, and
            therefore easier for clients to store and pass around.  For example,
            if you arrive at this DRS JSON by resolving a compact
            identifier-based DRS URI, the `self_uri` presents you with a
            hostname and properly encoded DRS ID for use in subsequent `access`
            endpoint calls.
          example: 'drs://drs.example.org/314159'
        size:
          type: integer
          format: int64
          description: >-
            For blobs, the blob size in bytes.

            For bundles, the cumulative size, in bytes, of items in the
            `contents` field.
        created_time:
          type: string
          format: date-time
          description: >-
            Timestamp of content creation in RFC3339.

            (This is the creation time of the underlying content, not of the
            JSON object.)
        updated_time:
          type: string
          format: date-time
          description: >-
            Timestamp of content update in RFC3339, identical to `created_time`
            in systems that do not support updates. (This is the update time of
            the underlying content, not of the JSON object.)
        version:
          type: string
          description: >-
            A string representing a version.

            (Some systems may use checksum, a RFC3339 timestamp, or an
            incrementing version number.)
        mime_type:
          type: string
          description: A string providing the mime-type of the `DrsObject`.
          example: application/json
        checksums:
          type: array
          minItems: 1
          items:
            $ref: '#/components/schemas/Checksum'
          description: >-
            The checksum of the `DrsObject`. At least one checksum must be
            provided.

            For blobs, the checksum is computed over the bytes in the blob.


            For bundles, the checksum is computed over a sorted concatenation of
            the checksums of its top-level contained objects (not recursive,
            names not included). The list of checksums is sorted alphabetically
            (hex-code) before concatenation and a further checksum is performed
            on the concatenated checksum value.


            For example, if a bundle contains blobs with the following
            checksums:

            md5(blob1) = 72794b6d

            md5(blob2) = 5e089d29


            Then the checksum of the bundle is:

            md5( concat( sort( md5(blob1), md5(blob2) ) ) )

            = md5( concat( sort( 72794b6d, 5e089d29 ) ) )

            = md5( concat( 5e089d29, 72794b6d ) )

            = md5( 5e089d2972794b6d )

            = f7a29a04
        access_methods:
          type: array
          minItems: 1
          items:
            $ref: '#/components/schemas/AccessMethod'
          description: >-
            The list of access methods that can be used to fetch the
            `DrsObject`.

            Required for single blobs; optional for bundles.
        contents:
          type: array
          description: >-
            If not set, this `DrsObject` is a single blob.

            If set, this `DrsObject` is a bundle containing the listed
            `ContentsObject` s (some of which may be further nested).
          items:
            $ref: '#/components/schemas/ContentsObject'
        description:
          type: string
          description: A human readable description of the `DrsObject`.
        aliases:
          type: array
          items:
            type: string
          description: >-
            A list of strings that can be used to find other metadata about this
            `DrsObject` from external metadata sources. These aliases can be
            used to represent secondary accession numbers or external GUIDs.
    AccessURL:
      type: object
      required:
        - url
      properties:
        url:
          type: string
          description: >-
            A fully resolvable URL that can be used to fetch the actual object
            bytes.
        headers:
          type: array
          items:
            type: string
          description: >-
            An optional list of headers to include in the HTTP request to `url`.
            These headers can be used to provide auth tokens required to fetch
            the object bytes.
          example: 'Authorization: Basic Z2E0Z2g6ZHJz'
    AccessMethod:
      type: object
      required:
        - type
      properties:
        type:
          type: string
          enum:
            - s3
            - gs
            - ftp
            - gsiftp
            - globus
            - htsget
            - https
            - file
          description: Type of the access method.
        access_url:
          $ref: '#/components/schemas/AccessURL'
          description: >-
            An `AccessURL` that can be used to fetch the actual object bytes.
            Note that at least one of `access_url` and `access_id` must be
            provided.
        access_id:
          type: string
          description: >-
            An arbitrary string to be passed to the `/access` method to get an
            `AccessURL`. This string must be unique within the scope of a single
            object. Note that at least one of `access_url` and `access_id` must
            be provided.
        region:
          type: string
          description: >-
            Name of the region in the cloud service provider that the object
            belongs to.
          example: us-east-1
    Error:
      type: object
      description: An object that can optionally include information about the error.
      properties:
        msg:
          type: string
          description: A detailed error message.
        status_code:
          type: integer
          description: 'The integer representing the HTTP status code (e.g. 200, 404).'
    ContentsObject:
      type: object
      required:
        - name
      properties:
        name:
          type: string
          description: >-
            A name declared by the bundle author that must be used when
            materialising this object, overriding any name directly associated
            with the object itself. The name must be unique with the containing
            bundle. This string is made up of uppercase and lowercase letters,
            decimal digits, hypen, period, and underscore [A-Za-z0-9.-_]. See
            http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_282[portable
            filenames].
        id:
          type: string
          description: >-
            A DRS identifier of a `DrsObject` (either a single blob or a nested
            bundle). If this ContentsObject is an object within a nested bundle,
            then the id is optional. Otherwise, the id is required.
        drs_uri:
          type: array
          description: >-
            A list of full DRS identifier URI paths that may be used to obtain
            the object. These URIs may be external to this DRS instance.
          example: 'drs://drs.example.org/314159'
          items:
            type: string
        contents:
          type: array
          description: >-
            If this ContentsObject describes a nested bundle and the caller
            specified "?expand=true" on the request, then this contents array
            must be present and describe the objects within the nested bundle.
          items:
            $ref: '#/components/schemas/ContentsObject'
  parameters:
    objectId:
      in: path
      name: object_id
      required: true
      description: '`DrsObject` identifier'
      schema:
        type: string
    accessId:
      in: path
      name: access_id
      required: true
      description: An `access_id` from the `access_methods` list of a `DrsObject`
      schema:
        type: string
    expand:
      in: query
      name: expand
      schema:
        type: boolean
        example: false
      description: >-
        If false and the object_id refers to a bundle, then the ContentsObject
        array contains only those objects directly contained in the bundle. That
        is, if the bundle contains other bundles, those other bundles are not
        recursively included in the result.

        If true and the object_id refers to a bundle, then the entire set of
        objects in the bundle is expanded. That is, if the bundle contains
        aother bundles, then those other bundles are recursively expanded and
        included in the result. Recursion continues through the entire sub-tree
        of the bundle.

        If the object_id refers to a blob, then the query parameter is ignored.
  securitySchemes:
    BasicAuth:
      type: http
      scheme: basic
      description: >
        A valid authorization token must be passed in the 'Authorization'
        header,

        e.g. "Basic ${token_string}"
    BearerAuth:
      type: http
      scheme: bearer
      description: >-
        A valid authorization token must be passed in the 'Authorization'
        header, e.g. "Bearer ${token_string}"
  responses:
    200OkDrsObject:
      description: The `DrsObject` was found successfully
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/DrsObject'
    200OkAccess:
      description: The `AccessURL` was found successfully
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AccessURL'
    202Accepted:
      description: >
        The operation is delayed and will continue asynchronously. The client
        should retry this same request after the delay specified by Retry-After
        header.
      headers:
        Retry-After:
          description: >
            Delay in seconds. The client should retry this same request after
            waiting for this duration. To simplify client response processing,
            this must be an integral relative time in seconds. This value SHOULD
            represent the minimum duration the client should wait before
            attempting the operation again with a reasonable expectation of
            success. When it is not feasible for the server to determine the
            actual expected delay, the server may return a brief, fixed value
            instead.
          schema:
            type: integer
            format: int64
    400BadRequest:
      description: The request is malformed.
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    401Unauthorized:
      description: The request is unauthorized.
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    403Forbidden:
      description: The requester is not authorized to perform this action.
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    404NotFoundDrsObject:
      description: The requested `DrsObject` wasn't found.
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    404NotFoundAccess:
      description: The requested `DrsObject` or `AccessURL` wasn't found.
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    500InternalServerError:
      description: An unexpected error occurred.
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
tags:
  - name: DataRepositoryService
